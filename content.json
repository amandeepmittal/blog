{"meta":{"title":"Aman Mittal's Blog","subtitle":"Node.js Blog","description":"I just find Node.js adroable...","author":"Aman Mittal","url":"http://amandeepmittal.github.io/blog"},"pages":[],"posts":[{"title":"How Node.js Works?","slug":"How-Node-js-Works","date":"2017-04-19T05:54:37.000Z","updated":"2017-04-19T05:54:37.000Z","comments":true,"path":"2017/04/19/How-Node-js-Works/","link":"","permalink":"http://amandeepmittal.github.io/blog/blog/2017/04/19/How-Node-js-Works/","excerpt":"When I started learning Node.js I always wondered, how does it work? How is it inside Node.js? Event loop and Event Queue jargons are digested. But what exactly is going on? Where do those jargons Event Loop and Event Queue come from.To satisfy my curiosity as well to know the answer to my previous question, I went in depth as much as I can and came across some things which I’d like to share with you. In brief, this article is about Node.js System — a glimpse of internal workings of Node.","text":"When I started learning Node.js I always wondered, how does it work? How is it inside Node.js? Event loop and Event Queue jargons are digested. But what exactly is going on? Where do those jargons Event Loop and Event Queue come from.To satisfy my curiosity as well to know the answer to my previous question, I went in depth as much as I can and came across some things which I’d like to share with you. In brief, this article is about Node.js System — a glimpse of internal workings of Node. If you are familiar with Node.js, it is a known fact that Node.js is single threaded. If you are from programming/computer science background you know what a thread means. Consider this scenario: traditionally — an I/O request comes to a web server and is assigned to an available thread, and for each concurrent connection there is one thread available. That request is handled on the specific thread until it is fulfilled and the response is sent. This scenario is a perfect example of Blocking I/O because while handling a particular request by a specific thread, there will be some idle time when the operations are being done (such as retrieving a file, opening it, reading it, etc.). A single thread consumes memory. A longer running thread for each connection and then sitting idly for some amount of time is not considered an efficient way in the world of Node.js. Enter Reactor Pattern- Heart of Node.jsReactor Pattern is an idea of non-blocking I/O operations in Node.js. This pattern provides a handler(in case of Node.js, a callback function) that is associated with each I/O operation. When an I/O request is generated, it is submitted to a demultiplexer. This demultiplexer is a notification interface that is used to handle concurrency in non-blocking I/O mode and collects every request in form of an event and queues each event in a queue. Thus, the demultiplexer provides the Event Queue, which we often hear. When a request is collected by the demultiplexer, it returns the control back to the system and does not blocks the I/O. At the same time, there is an Event Loop which iterates over the items in the Event Queue. Every event has a callback function associated with it, and that callback function is invoked when the Event Loop iterates. The callback function further mostly have other callbacks associated within representing some asynchronous operations. These operations are inserted in the Event Queue by the demultiplexer and are ready to be processed once the Event Loop iterates over them. That is why calls to other operations must be asynchronous. When all the items in the Event Queue are processed and there are no pending operations left, Node.js terminates the application automatically. Building Blocks of Node.js Reactor Pattern libuv A set of Bindings Chrome’s V8 Core JS Library libuvPronounced as “lib u v”, is library written in C language to make Node.js compatible with every OS and provide the non-blocking I/O behaviour. libuv is a low-level engine that implements reactor pattern thus providing an API for creating the Event Loop, managing an Event Queue and running asynchronous I/O operations. It is built specifically to provide a unified experience over different Operating Systems. Need for libuv?Each operating system has its own interface for the demultiplexer. Such as Kqueue for Mac OS X, IOCP for Windows and [Epoll]https://en.wikipedia.org/wiki/Epoll for Linux. Different multiplexers will behave differently when handling an I/O request. And then, each I/O operation can differ in its behaviour within the same operating system. This creates an inconsistency and to overcome this inconsistency libuv is the solution. I am not going to talk about internal workings of libuv here, not an expert on that, myself. For more info on libuv check their docs or this slide by Saúl Ibarra Corretgé (@saghul) is a good start. Also, libuv is independently maintained by awesome developers. Set of BindingsThese set of bindings are responsible for wrapping and exposing libuv and other low-level functionality to JavaScript. V8It’s a runtime engine developed by Google for Chrome browser for JavaScript. It is the reason Node.js is fast and efficient. Core LibraryThis is a JavaScript library that implements high-level Node.js API (a.k.a. node-core).","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://amandeepmittal.github.io/blog/tags/nodejs/"}]},{"title":"Modules in Angularjs","slug":"Modules-in-Angularjs","date":"2017-04-14T06:50:12.000Z","updated":"2017-04-14T07:08:40.000Z","comments":true,"path":"2017/04/14/Modules-in-Angularjs/","link":"","permalink":"http://amandeepmittal.github.io/blog/blog/2017/04/14/Modules-in-Angularjs/","excerpt":"Modules are essential part of developing an AngularJS application. Modules provide resusability of code. A module in AngularJS act as a container that holds/groups different components.","text":"Modules are essential part of developing an AngularJS application. Modules provide resusability of code. A module in AngularJS act as a container that holds/groups different components. Creating a simple Moduleangular.module function is used to create a module whenever necessary. The first argument is always the module name and the second argument is an array that specifies additional modules upon which are current module depends. If there’s no dependency, pass an empty array 12345// module with no dependencyangular.module('moduleA', []);// module with dependenciesangular.module('moduleB', ['moduleA', 'moduleC']); After creating a module, different components are bind with it. 12345var myModule = angular.module('moduleA', []);myModule.controller(...);myModule.service(...); The above code creates a new module and attaches two components with it: a controller, and a directive. It also declares a global variable myModule in the JavaScript global namespace. Imagine a large app with vast amount of global variables like this. To avoid this situation of populating JavaScript global namespace, we can declare the whole code inside an IIFE. 123456789(function() &#123; var myModule = angular.module('moduleA', []); myModule.controller(...); myModule.service(...);&#125;)();// myModule is undefined here This function will execute as soon as it’s declared. There’s alternative procedure in which IIFE can be avoided, and is simple. Call the Angular Module with a single argument. When an angular module is called with a single argument, it retrieves the already created module and returns it. 1234angular.module('moduleA', []);angular.module('firstModule').controller(...);angular.module('firstModule').directive(...); Alternatively, to avoid boilerplate, components such as controllers and directives can be chained with the module declaration. 123angular.module('moduleA', []) // notice no semicolon.controller(...).directive(...); // notice the semicolon","categories":[],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://amandeepmittal.github.io/blog/tags/angularjs/"}]},{"title":"The Node Way: Philosophy of a Platform","slug":"The-Node-Way-Philosophy-of-a-Platform","date":"2017-04-05T13:01:29.000Z","updated":"2017-04-19T05:53:27.000Z","comments":true,"path":"2017/04/05/The-Node-Way-Philosophy-of-a-Platform/","link":"","permalink":"http://amandeepmittal.github.io/blog/blog/2017/04/05/The-Node-Way-Philosophy-of-a-Platform/","excerpt":"Last week, when Node.js community introduced its logo, it got me into thinking of why this technology as fresh in my mind as when I was first introduced to it a few months back. Why is that spark still ignited in the back of my head? The answer to this is the philosophy behind the technology of Node.js platform.","text":"Last week, when Node.js community introduced its logo, it got me into thinking of why this technology as fresh in my mind as when I was first introduced to it a few months back. Why is that spark still ignited in the back of my head? The answer to this is the philosophy behind the technology of Node.js platform. Every platform has its own philosophy, its own set of rules, its own principles and guidelines. This is necessary for the evolution of a platform and is important for developing an application using that platform. (Otherwise, we all can get carried away.) Node.js has its own philosophy, since its a platform, and it manages to find a middleground between JavaScript and UNIX. Two of the most important principles of UNIX that are adaptable in Node.js are: Modularity, keeping simple parts short, connected with clean interfaces. A program should do one thing and it should do that awesomely. Other rules described by Eric Steven Raymond in The Art of UNIX Programming might fit to some extent but the two aforementioned are necessary to use Node.js pragmatically. In Node.js this pragmaticism is provided the by a ‘module’. A module is the fundamental to structure the code of a program in Node.js. Module is also the building block of a package. (A package is any application or reusable libraries). The principle here is to design small modules in terms of code and in terms of application scope. This principle provides: reusability of code easier to understand the code thus, making it simple to test and maintain Another important aspect in the Node Philosophy is the dependency of each package. Writing a Node.js application, one tends to use a lot of packages (which is the genesis of Node.js Ecosystem: npm) and this might create a common problem known as: dependency hell. To overcome this conflict, Node.js manages dependencies of each installed package to have its own separate set of dependencies. ORIGINALLY PUBLISHED at Medium.com on March 10, 2016.","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://amandeepmittal.github.io/blog/tags/nodejs/"}]},{"title":"JavaScript Code Conventions","slug":"JavaScript-Code-Conventions","date":"2017-04-03T17:31:43.000Z","updated":"2017-04-05T13:03:42.000Z","comments":true,"path":"2017/04/03/JavaScript-Code-Conventions/","link":"","permalink":"http://amandeepmittal.github.io/blog/blog/2017/04/03/JavaScript-Code-Conventions/","excerpt":"This article is about coding conventions. Everywhere I read good/better/awesome articles but very few seem to talk about the the basic things in programming.","text":"This article is about coding conventions. Everywhere I read good/better/awesome articles but very few seem to talk about the the basic things in programming. Like the coding conventions used by programmers in their work. I am a JavaScript enthusiast and never once did I came across a good article on basic conventions and guidelines to write code that is helpful for me and others to read my code.Thus, this is my attempt and this article contains some general coding conventions as well as some specific guidelines only applicable to JavaScript. Thus, this is my attempt and this article contains some general coding conventions as well as some specific guidelines only applicable to JavaScript. So what are Code Conventions?These are the guidelines about programming practices, file and directory structure and commenting. Now you may be wondering why do you need guidelines as for files and directory structure? Well, to keep simple and when working in a team you have to follow some rules for a specific file structure for that application. Otherwise it will be huge mess. Style GuidelinesThey are the type of Code Convention that includes the layout of code within a file. IndentationThe first thing to do when writing code in a file is how to handle indentation. 12345678910if(num===1)&#123; for(i=0;i&lt;array.length;i++)&#123; if(array[i]!==0)&#123; //some code &#125; else if(array[i]===array.length)&#123; // code &#125; &#125;&#125; Observe in the previous example there is a flow. This is what an indentation is all about. It makes the program readable. The else if statement is used for the if statement inside the for loop and not the outside if statement. Two ways to achieve indentation: using tabs using spaces Using TabsFor each indentation level, use one tab character. Thus, the second level will have two tab characters and so on. Using SpaceEach indentation level is made up of multiple spaces. The levels contains spaces in pairs, like two spaces for first level, and four spaces for second level and so on. The advantage of using spaces over tabs is that all text editors are configured according to spaces and is treated exactly the same. The disadvantage here is to put spaces in each line. Thankfully, we are in an era where text editors are smart enough and they automatically do indentation. Avoid ASI Automatic Semicolon InsertionAvoiding semicolons is possible and if JavaScript has a mechanism called ASI, why the hell to care about semicolons? If you are comfortable with ASI carry on. But the rules of ASI are complex and using your time with in writing code rather than worrying about ASI is better. It causes errors and sometimes things won’t work because the JavaScript parser may read things different from the way they are written. Also, semicolons improves the readability of the code for other programmers too. If you are working collaboratively, it’s a great help. Avoid Horizontal ScrollingThe recommended length of code in a line is 80 characters. Even though the text editors have become smart, the length of 80 characters has is still used as a convention. Blank Lines are not harmfulUsing blank lines to separate unrelated lines of code. It improves readability. Without blank lines: 12345678910if(num===1)&#123; for(i=0;i&lt;array.length;i++)&#123; if(array[i]!==0)&#123; //some code &#125; else if(array[i]===array.length)&#123; // code &#125; &#125;&#125; With blank lines:12345678910if(num===1)&#123; for(i=0;i&lt;array.length;i++)&#123; if(array[i]!==0)&#123; //some code &#125; else if(array[i]===array.length)&#123; // code &#125; &#125;&#125; Naming ConventionECMAScript uses camelCase convention. You should too when naming Variables and Functions. And try to use meaningful names for those variables and functions and keep them short. Function NamingIn JS, all we do is make functions in form of callbacks andevents. Author of Maintainable Javascript Nicholas Zakas introduces some common conventions for functions. I find these helpful: can Function that returns a boolean has Function that returns a boolean is Function that returns a boolean get Function that returns a nonboolean set Function that is used to save a value ConstructorsConstructors are functions too and are used to create objects via new operator. But avoid using camelCase and use PascalCase instead. It is helpful since JavaScript uses the same for naming pre-defined constructors. CommentsFor single-line comments, I observed this when using JSHint, after // use a space between them(the two slashes) and the comment. 1// Single-Line Comment Following all conventions of can be hard and a stressful matter at times when you are focusing on the logic part of the code. Thus, there is an alternative which works for me most of the time, is the Beautify package that I use in the text editor Atom and I am sure it is available for the majority of other text editors. Subscribe to my newsletter ORIGINALLY PUBLISHED at Medium.com on January 8, 2016.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://amandeepmittal.github.io/blog/tags/javascript/"}]}]}